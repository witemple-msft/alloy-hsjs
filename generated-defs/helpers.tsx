// Copyright (c) Microsoft Corporation
// Licensed under the MIT license.

// prettier-ignore

import * as ay from "@alloy-js/core";

import { Helper, HelperModule } from "../src/components/helpers.js";

const _helpers = {
  "temporal": {
    "native": {
      name: "native.ts",
      code: "// Copyright (c) Microsoft Corporation\n// Licensed under the MIT license.\n\n// Due to the lack of generally-available global type definitions for Temporal, we use `any` throughout this module.\n// When global.d.ts eventually has definitions for Temporal, we can unify this module with `polyfill.ts`.\n\n/**\n * Parses an HTTP date string (e.g. `Wed, 21 Oct 2015 07:28:00 GMT`) into a `Temporal.Instant`.\n * The date string must be in the format specified by RFC 7231.\n *\n * @param httpDate - The HTTP date string to parse.\n * @throws {RangeError} If the date string is invalid or cannot be parsed.\n * @returns The parsed `Temporal.Instant`.\n */\nexport function parseHttpDate(httpDate: string): any {\n  const timestamp = globalThis.Date.parse(httpDate);\n\n  if (isNaN(timestamp)) {\n    throw new RangeError(`Invalid HTTP date: ${httpDate}`);\n  }\n\n  return (globalThis as any).Temporal.Instant.fromEpochMilliseconds(timestamp);\n}\n\n/**\n * Formats a `Temporal.Instant` into an HTTP date string (e.g. `Wed, 21 Oct 2015 07:28:00 GMT`).\n * The date string is formatted according to RFC 7231.\n *\n * @param instant - The `Temporal.Instant` to format.\n * @returns The formatted HTTP date string.\n */\nexport function formatHttpDate(instant: any) {\n  const date = new Date(instant.epochMilliseconds);\n  return date.toUTCString();\n}\n\n/**\n * Converts a `Temporal.Duration` to a number of seconds.\n * This method will throw an Error if the duration contains any years, months, weeks, or days, as those require a reference\n * point to calculate the total number of seconds.\n *\n * WARNING: If the total number of seconds is larger than the maximum safe integer in JavaScript, this method will\n * lose precision. @see durationTotalSecondsBigInt for a BigInt alternative.\n *\n * @param duration - the duration to calculate the total number of seconds for\n * @returns the total number of seconds in the duration\n */\nexport function durationTotalSeconds(duration: any): number {\n  if (\n    duration.years !== 0 ||\n    duration.months !== 0 ||\n    duration.weeks !== 0 ||\n    duration.days !== 0\n  ) {\n    throw new Error(\n      \"Cannot calculate total seconds for a duration with years, months, weeks, or days.\",\n    );\n  }\n\n  return (\n    duration.seconds +\n    duration.minutes * 60 +\n    duration.hours * 60 * 60 +\n    duration.days * 24 * 60 * 60\n  );\n}\n\n/**\n * Gets the total number of seconds in a duration.\n *\n * This method will throw an Error if the duration contains any years, months, weeks, or days, as those require a reference\n * point to calculate the total number of seconds. It will also throw an error if any of the components are not integers.\n *\n * @param duration - the duration to calculate the total number of seconds for\n * @returns the total number of seconds in the duration\n */\nexport function durationTotalSecondsBigInt(duration: any): bigint {\n  if (\n    duration.years !== 0 ||\n    duration.months !== 0 ||\n    duration.weeks !== 0 ||\n    duration.days !== 0\n  ) {\n    throw new Error(\n      \"Cannot calculate total seconds for a duration with years, months, weeks, or days.\",\n    );\n  }\n\n  if (\n    !Number.isInteger(duration.seconds) ||\n    !Number.isInteger(duration.minutes) ||\n    !Number.isInteger(duration.hours) ||\n    !Number.isInteger(duration.days)\n  ) {\n    throw new Error(\"Duration components must be integers.\");\n  }\n\n  return (\n    BigInt(duration.seconds) +\n    BigInt(duration.minutes) * 60n +\n    BigInt(duration.hours) * 60n * 60n +\n    BigInt(duration.days) * 24n * 60n * 60n\n  );\n}\n",
    },
    "polyfill": {
      name: "polyfill.ts",
      code: "// Copyright (c) Microsoft Corporation\n// Licensed under the MIT license.\n\nimport { Temporal } from \"temporal-polyfill\";\n\n/**\n * Parses an HTTP date string (e.g. `Wed, 21 Oct 2015 07:28:00 GMT`) into a `Temporal.Instant`.\n * The date string must be in the format specified by RFC 7231.\n *\n * @param httpDate - The HTTP date string to parse.\n * @throws {RangeError} If the date string is invalid or cannot be parsed.\n * @returns The parsed `Temporal.Instant`.\n */\nexport function parseHttpDate(httpDate: string): Temporal.Instant {\n  const timestamp = globalThis.Date.parse(httpDate);\n\n  if (isNaN(timestamp)) {\n    throw new RangeError(`Invalid HTTP date: ${httpDate}`);\n  }\n\n  return Temporal.Instant.fromEpochMilliseconds(timestamp);\n}\n\n/**\n * Formats a `Temporal.Instant` into an HTTP date string (e.g. `Wed, 21 Oct 2015 07:28:00 GMT`).\n * The date string is formatted according to RFC 7231.\n *\n * @param instant - The `Temporal.Instant` to format.\n * @returns The formatted HTTP date string.\n */\nexport function formatHttpDate(instant: Temporal.Instant) {\n  const date = new Date(instant.epochMilliseconds);\n  return date.toUTCString();\n}\n\n/**\n * Converts a `Temporal.Duration` to a number of seconds.\n * This method will throw an Error if the duration contains any years, months, weeks, or days, as those require a reference\n * point to calculate the total number of seconds.\n *\n * WARNING: If the total number of seconds is larger than the maximum safe integer in JavaScript, this method will\n * lose precision. @see durationTotalSecondsBigInt for a BigInt alternative.\n *\n * @param duration - the duration to calculate the total number of seconds for\n * @returns the total number of seconds in the duration\n */\nexport function durationTotalSeconds(duration: Temporal.Duration): number {\n  if (\n    duration.years !== 0 ||\n    duration.months !== 0 ||\n    duration.weeks !== 0 ||\n    duration.days !== 0\n  ) {\n    throw new Error(\n      \"Cannot calculate total seconds for a duration with years, months, weeks, or days.\",\n    );\n  }\n\n  return (\n    duration.seconds +\n    duration.minutes * 60 +\n    duration.hours * 60 * 60 +\n    duration.days * 24 * 60 * 60\n  );\n}\n\n/**\n * Gets the total number of seconds in a duration.\n *\n * This method will throw an Error if the duration contains any years, months, weeks, or days, as those require a reference\n * point to calculate the total number of seconds. It will also throw an error if any of the components are not integers.\n *\n * @param duration - the duration to calculate the total number of seconds for\n * @returns the total number of seconds in the duration\n */\nexport function durationTotalSecondsBigInt(duration: Temporal.Duration): bigint {\n  if (\n    duration.years !== 0 ||\n    duration.months !== 0 ||\n    duration.weeks !== 0 ||\n    duration.days !== 0\n  ) {\n    throw new Error(\n      \"Cannot calculate total seconds for a duration with years, months, weeks, or days.\",\n    );\n  }\n\n  if (\n    !Number.isInteger(duration.seconds) ||\n    !Number.isInteger(duration.minutes) ||\n    !Number.isInteger(duration.hours) ||\n    !Number.isInteger(duration.days)\n  ) {\n    throw new Error(\"Duration components must be integers.\");\n  }\n\n  return (\n    BigInt(duration.seconds) +\n    BigInt(duration.minutes) * 60n +\n    BigInt(duration.hours) * 60n * 60n +\n    BigInt(duration.days) * 24n * 60n * 60n\n  );\n}\n",
      externalDependencies: [
      "temporal-polyfill"
      ],
    },
  },
  "datetime": {
    name: "datetime.ts",
    code: "// Copyright (c) Microsoft Corporation\n// Licensed under the MIT license.\n\n// #region Duration\n\n/**\n * Regular expression for matching ISO8601 duration strings.\n *\n * Yields:\n * - 0: the full match\n * - 1: the sign (optional)\n * - 2: years (optional)\n * - 3: months (optional)\n * - 4: weeks (optional)\n * - 5: days (optional)\n * - 6: hours (optional)\n * - 7: minutes (optional)\n * - 8: seconds (optional)\n */\nconst ISO8601_DURATION_REGEX =\n  /^(-)?P(?:((?:\\d*[.,])?\\d+)Y)?(?:((?:\\d*[.,])?\\d+)M)?(?:((?:\\d*[.,])?\\d+)W)?(?:((?:\\d*[.,])?\\d+)D)?(?:T(?:((?:\\d*[.,])?\\d+)H)?(?:((?:\\d*[.,])?\\d+)M)?(?:((?:\\d*[.,])?\\d+)S)?)?$/;\n\n/**\n * A duration of time, measured in years, months, weeks, days, hours, minutes, and seconds.\n *\n * The values may be fractional and are not normalized (e.g. 36 hours is not the same duration as 1 day and 12 hours\n * when accounting for Daylight Saving Time changes or leap seconds).\n *\n * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n */\nexport interface Duration {\n  /**\n   * \"+\" if the duration is positive, \"-\" if the duration is negative.\n   */\n  sign: \"+\" | \"-\";\n  /**\n   * The number of years in the duration.\n   */\n  years: number;\n  /**\n   * The number of months in the duration.\n   */\n  months: number;\n  /**\n   * The number of weeks in the duration.\n   */\n  weeks: number;\n  /**\n   * The number of days in the duration.\n   */\n  days: number;\n  /**\n   * The number of hours in the duration.\n   */\n  hours: number;\n  /**\n   * The number of minutes in the duration.\n   */\n  minutes: number;\n  /**\n   * The number of seconds in the duration.\n   */\n  seconds: number;\n}\n\nexport const Duration = Object.freeze({\n  /**\n   * Parses an ISO8601 duration string into an object.\n   *\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   *\n   * @param duration - the duration string to parse\n   * @returns an object containing the parsed duration\n   */\n  parseISO8601(duration: string, maxLength: number = 100): Duration {\n    duration = duration.trim();\n    if (duration.length > maxLength)\n      throw new Error(`ISO8601 duration string is too long: ${duration}`);\n\n    const match = duration.match(ISO8601_DURATION_REGEX);\n\n    if (!match) throw new Error(`Invalid ISO8601 duration: ${duration}`);\n\n    return {\n      sign: match[1] === undefined ? \"+\" : (match[1] as Duration[\"sign\"]),\n      years: parseFloatNormal(match[2]),\n      months: parseFloatNormal(match[3]),\n      weeks: parseFloatNormal(match[4]),\n      days: parseFloatNormal(match[5]),\n      hours: parseFloatNormal(match[6]),\n      minutes: parseFloatNormal(match[7]),\n      seconds: parseFloatNormal(match[8]),\n    };\n\n    function parseFloatNormal(match: string | undefined): number {\n      if (match === undefined) return 0;\n\n      const normalized = match.replace(\",\", \".\");\n\n      const parsed = parseFloat(normalized);\n\n      if (isNaN(parsed))\n        throw new Error(`Unreachable: Invalid number in ISO8601 duration string: ${match}`);\n\n      return parsed;\n    }\n  },\n  /**\n   * Writes a Duration to an ISO8601 duration string.\n   *\n   * @see https://en.wikipedia.org/wiki/ISO_8601#Durations\n   *\n   * @param duration - the duration to write to a string\n   * @returns a string in ISO8601 duration format\n   */\n  toISO8601(duration: Duration): string {\n    const sign = duration.sign === \"+\" ? \"\" : \"-\";\n\n    const years =\n      duration.years !== 0 && !isNaN(Number(duration.years)) ? `${duration.years}Y` : \"\";\n    const months =\n      duration.months !== 0 && !isNaN(Number(duration.months)) ? `${duration.months}M` : \"\";\n    const weeks =\n      duration.weeks !== 0 && !isNaN(Number(duration.weeks)) ? `${duration.weeks}W` : \"\";\n    const days = duration.days !== 0 && !isNaN(Number(duration.days)) ? `${duration.days}D` : \"\";\n\n    let time = \"\";\n\n    const _hours = duration.hours !== 0 && !isNaN(Number(duration.hours));\n    const _minutes = duration.minutes !== 0 && !isNaN(Number(duration.minutes));\n    const _seconds = duration.seconds !== 0 && !isNaN(Number(duration.seconds));\n\n    if (_hours || _minutes || _seconds) {\n      const hours = _hours ? `${duration.hours}H` : \"\";\n      const minutes = _minutes ? `${duration.minutes}M` : \"\";\n      const seconds = _seconds ? `${duration.seconds}S` : \"\";\n\n      time = `T${hours}${minutes}${seconds}`;\n    }\n\n    return `${sign}P${years}${months}${weeks}${days}${time}`;\n  },\n\n  /**\n   * Gets the total number of seconds in a duration.\n   *\n   * This method will throw an Error if the duration contains any years, months, weeks, or days, as those require a reference\n   * point to calculate the total number of seconds.\n   *\n   * WARNING: If the total number of seconds is larger than the maximum safe integer in JavaScript, this method will\n   * lose precision. @see Duration.totalSecondsBigInt for a BigInt alternative.\n   *\n   * @param duration - the duration to calculate the total number of seconds for\n   * @returns the total number of seconds in the duration\n   */\n  totalSeconds(duration: Duration): number {\n    if (\n      duration.years !== 0 ||\n      duration.months !== 0 ||\n      duration.weeks !== 0 ||\n      duration.days !== 0\n    ) {\n      throw new Error(\n        \"Cannot calculate total seconds for a duration with years, months, weeks, or days.\",\n      );\n    }\n\n    return (\n      duration.seconds +\n      duration.minutes * 60 +\n      duration.hours * 60 * 60 +\n      duration.weeks * 7 * 24 * 60 * 60\n    );\n  },\n\n  /**\n   * Gets the total number of seconds in a duration.\n   *\n   * This method will throw an Error if the duration contains any years, months, weeks, or days, as those require a reference\n   * point to calculate the total number of seconds. It will also throw an error if any of the components are not integers.\n   *\n   * @param duration - the duration to calculate the total number of seconds for\n   * @returns the total number of seconds in the duration\n   */\n  totalSecondsBigInt(duration: Duration): bigint {\n    if (\n      duration.years !== 0 ||\n      duration.months !== 0 ||\n      duration.weeks !== 0 ||\n      duration.days !== 0\n    ) {\n      throw new Error(\n        \"Cannot calculate total seconds for a duration with years, months, weeks, or days.\",\n      );\n    }\n\n    if (\n      !Number.isInteger(duration.seconds) ||\n      !Number.isInteger(duration.minutes) ||\n      !Number.isInteger(duration.hours) ||\n      !Number.isInteger(duration.weeks)\n    ) {\n      throw new Error(\n        \"Cannot calculate total seconds as a BigInt for a duration with non-integer components.\",\n      );\n    }\n\n    return (\n      BigInt(duration.seconds) +\n      BigInt(duration.minutes) * 60n +\n      BigInt(duration.hours) * 60n * 60n +\n      BigInt(duration.weeks) * 7n * 24n * 60n * 60n\n    );\n  },\n\n  /**\n   * Creates a duration from a total number of seconds.\n   *\n   * The result is not normalized, so it will only contain a seconds field.\n   */\n  fromTotalSeconds(seconds: number): Duration {\n    return {\n      sign: seconds < 0 ? \"-\" : \"+\",\n      years: 0,\n      months: 0,\n      weeks: 0,\n      days: 0,\n      hours: 0,\n      minutes: 0,\n      seconds: Math.abs(seconds),\n    };\n  },\n});\n\n// #endregion\n",
  },
  "header": {
    name: "header.ts",
    code: "// Copyright (c) Microsoft Corporation\n// Licensed under the MIT license.\n\nexport interface HeaderValueParameters {\n  value: string;\n  verbatim: string;\n  params: { [k: string]: string };\n}\n\n/**\n * Parses a header value that may contain additional parameters (e.g. `text/html; charset=utf-8`).\n * @param headerValueText - the text of the header value to parse\n * @returns an object containing the value and a map of parameters\n */\nexport function parseHeaderValueParameters<Header extends string | undefined>(\n  headerValueText: Header,\n): undefined extends Header ? HeaderValueParameters | undefined : HeaderValueParameters {\n  if (headerValueText === undefined) {\n    return undefined as any;\n  }\n\n  const idx = headerValueText.indexOf(\";\");\n  const [value, _paramsText] =\n    idx === -1\n      ? [headerValueText, \"\"]\n      : [headerValueText.slice(0, idx), headerValueText.slice(idx + 1)];\n\n  let paramsText = _paramsText;\n\n  // Parameters are a sequence of key=value pairs separated by semicolons, but the value may be quoted in which case it\n  // may contain semicolons. We use a regular expression to iteratively split the parameters into key=value pairs.\n  const params: { [k: string]: string } = {};\n\n  let match;\n\n  // TODO: may need to support ext-parameter (e.g. \"filename*=UTF-8''%e2%82%ac%20rates\" => { filename: \"€ rates\" }).\n  // By default we decoded everything as UTF-8, and non-UTF-8 agents are a dying breed, but we may need to support\n  // this for completeness. If we do support it, we'll prefer an ext-parameter over a regular parameter. Currently, we'll\n  // just treat them as separate keys and put the raw value in the parameter.\n  //\n  // https://datatracker.ietf.org/doc/html/rfc5987#section-3.2.1\n  while ((match = paramsText.match(/\\s*([^=]+)=(?:\"([^\"]+)\"|([^;]+));?/))) {\n    const [, key, quotedValue, unquotedValue] = match;\n\n    params[key.trim()] = quotedValue ?? unquotedValue;\n\n    paramsText = paramsText.slice(match[0].length);\n  }\n\n  return {\n    value: value.trim(),\n    verbatim: headerValueText,\n    params,\n  };\n}\n",
  },
  "http": {
    name: "http.ts",
    code: "// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT License.\n\nimport { HttpContext } from \"./router.js\";\n\nexport const HTTP_RESPONDER = Symbol.for(\"@typespec/http-server-js.HttpResponder\");\n\n/**\n * A type that can respond to an HTTP request.\n */\nexport interface HttpResponder {\n  /**\n   * A function that handles an HTTP request and response.\n   *\n   * @param context - The HTTP context.\n   */\n  [HTTP_RESPONDER]: (context: HttpContext) => void;\n}\n\n/**\n * Determines if a value is an HttpResponder.\n * @param value - The value to check.\n * @returns `true` if the value is an HttpResponder, otherwise `false`.\n */\nexport function isHttpResponder(value: unknown): value is HttpResponder {\n  return (\n    typeof value === \"object\" &&\n    value !== null &&\n    HTTP_RESPONDER in value &&\n    typeof value[HTTP_RESPONDER] === \"function\"\n  );\n}\n\n/**\n * An Error that can respond to an HTTP request if thrown from a route handler.\n */\nexport class HttpResponderError extends Error implements HttpResponder {\n  #statusCode: number;\n\n  constructor(statusCode: number, message: string) {\n    super(message);\n    this.#statusCode = statusCode;\n  }\n\n  [HTTP_RESPONDER](ctx: HttpContext): void {\n    ctx.response.statusCode = this.#statusCode;\n    ctx.response.setHeader(\"Content-Type\", \"text/plain\");\n    ctx.response.end(this.message);\n  }\n}\n\n/**\n * The requested resource was not found.\n */\nexport class NotFoundError extends HttpResponderError {\n  constructor() {\n    super(404, \"Not Found\");\n  }\n}\n\n/**\n * The request was malformed.\n */\nexport class BadRequestError extends HttpResponderError {\n  constructor() {\n    super(400, \"Bad Request\");\n  }\n}\n\n/**\n * The request is missing required authentication credentials.\n */\nexport class UnauthorizedError extends HttpResponderError {\n  constructor() {\n    super(401, \"Unauthorized\");\n  }\n}\n\n/**\n * The request is missing required permissions.\n */\nexport class ForbiddenError extends HttpResponderError {\n  constructor() {\n    super(403, \"Forbidden\");\n  }\n}\n\n/**\n * The request conflicts with the current state of the server.\n */\nexport class ConflictError extends HttpResponderError {\n  constructor() {\n    super(409, \"Conflict\");\n  }\n}\n\n/**\n * The server encountered an unexpected condition that prevented it from fulfilling the request.\n */\nexport class InternalServerError extends HttpResponderError {\n  constructor() {\n    super(500, \"Internal Server Error\");\n  }\n}\n\n/**\n * The server does not support the functionality required to fulfill the request.\n */\nexport class NotImplementedError extends HttpResponderError {\n  constructor() {\n    super(501, \"Not Implemented\");\n  }\n}\n",
  },
  "json": {
    name: "json.ts",
    code: "// Copyright (c) Microsoft Corporation\n// Licensed under the MIT license.\n\n/**\n * A strongly-typed JSON value.\n */\nexport type JsonValue =\n  | string\n  | number\n  | boolean\n  | null\n  | JsonValue[]\n  | { [key: string]: JsonValue };\n\n/**\n * Parses a ReadableStream<Uint8Array> into a JSON value.\n *\n * @param body - The stream body of the request.\n * @param encoding - The encoding to use for decoding the stream as text. Defaults to \"utf-8\".\n * @returns A promise that resolves to the parsed JSON value.\n */\nexport function parseJson(\n  body: ReadableStream<Uint8Array>,\n  encoding: string = \"utf-8\",\n): Promise<JsonValue> {\n  return new Promise((resolve, reject) => {\n    const reader = body.getReader();\n    const decoder = new TextDecoder(encoding);\n    let result = \"\";\n\n    function read() {\n      reader\n        .read()\n        .then(({ done, value }) => {\n          if (done) {\n            try {\n              resolve(JSON.parse(result));\n            } catch (e) {\n              reject(e);\n            }\n            return;\n          }\n\n          result += decoder.decode(value, { stream: true });\n          read();\n        })\n        .catch(reject);\n    }\n\n    read();\n  });\n}\n",
  },
  "multipart": {
    name: "multipart.ts",
    code: "// Copyright (c) Microsoft Corporation\n// Licensed under the MIT license.\n\nimport type * as http from \"node:http\";\n\nexport interface HttpPart {\n  headers: { [k: string]: string | undefined };\n  body: ReadableStream<Buffer>;\n}\n\n/**\n * Consumes a stream of incoming data and splits it into individual streams for each part of a multipart request, using\n * the provided `boundary` value.\n */\nfunction MultipartBoundaryTransformStream(\n  boundary: string,\n): ReadableWritablePair<ReadableStream<Buffer>, Buffer> {\n  let buffer: Buffer = Buffer.alloc(0);\n  // Initialize subcontroller to an object that does nothing. Multipart bodies may contain a preamble before the first\n  // boundary, so this dummy controller will discard it.\n  let subController: { enqueue(chunk: Buffer): void; close(): void } | null = {\n    enqueue() {},\n    close() {},\n  };\n\n  let boundarySplit = Buffer.from(`--${boundary}`);\n  let initialized = false;\n\n  // We need to keep at least the length of the boundary split plus room for CRLFCRLF in the buffer to detect the boundaries.\n  // We subtract one from this length because if the whole thing were in the buffer, we would detect it and move past it.\n  const bufferKeepLength = boundarySplit.length + BUF_CRLFCRLF.length - 1;\n  let _readableController: ReadableStreamDefaultController<ReadableStream<Buffer>> = null as any;\n\n  const readable = new ReadableStream<ReadableStream<Buffer>>({\n    start(controller) {\n      _readableController = controller;\n    },\n  });\n\n  const readableController = _readableController;\n\n  const writable = new WritableStream<Buffer>({\n    write: async (chunk) => {\n      buffer = Buffer.concat([buffer, chunk]);\n\n      let index: number;\n\n      while ((index = buffer.indexOf(boundarySplit)) !== -1) {\n        // We found a boundary, emit everything before it and initialize a new stream for the next part.\n\n        // We are initialized if we have found the boundary at least once.\n        //\n        // Cases\n        // 1. If the index is zero and we aren't initialized, there was no preamble.\n        // 2. If the index is zero and we are initialized, then we had to have found \\r\\n--boundary, nothing special to do.\n        // 3. If the index is not zero, and we are initialized, then we found \\r\\n--boundary somewhere in the middle,\n        //    nothing special to do.\n        // 4. If the index is not zero and we aren't initialized, then we need to check that boundarySplit was preceded\n        //    by \\r\\n for validity, because the preamble must end with \\r\\n.\n\n        if (index > 0) {\n          if (!initialized) {\n            if (!buffer.subarray(index - 2, index).equals(Buffer.from(\"\\r\\n\"))) {\n              readableController.error(new Error(\"Invalid preamble in multipart body.\"));\n            } else {\n              await enqueueSub(buffer.subarray(0, index - 2));\n            }\n          } else {\n            await enqueueSub(buffer.subarray(0, index));\n          }\n        }\n\n        // We enqueued everything before the boundary, so we clear the buffer past the boundary\n        buffer = buffer.subarray(index + boundarySplit.length);\n\n        // We're done with the current part, so close the stream. If this is the opening boundary, there won't be a\n        // subcontroller yet.\n        subController?.close();\n        subController = null;\n\n        if (!initialized) {\n          initialized = true;\n          boundarySplit = Buffer.from(`\\r\\n${boundarySplit}`);\n        }\n      }\n\n      if (buffer.length > bufferKeepLength) {\n        await enqueueSub(buffer.subarray(0, -bufferKeepLength));\n        buffer = buffer.subarray(-bufferKeepLength);\n      }\n    },\n    close() {\n      if (!/--(\\r\\n)?/.test(buffer.toString(\"utf-8\"))) {\n        readableController.error(new Error(\"Unexpected characters after final boundary.\"));\n      }\n\n      subController?.close();\n\n      readableController.close();\n    },\n  });\n\n  async function enqueueSub(s: Buffer) {\n    subController ??= await new Promise<ReadableStreamDefaultController>((resolve) => {\n      readableController.enqueue(\n        new ReadableStream<Buffer>({\n          start: (controller) => resolve(controller),\n        }),\n      );\n    });\n\n    subController.enqueue(s);\n  }\n\n  return { readable, writable };\n}\n\nconst BUF_CRLFCRLF = Buffer.from(\"\\r\\n\\r\\n\");\n\n/**\n * Consumes a stream of the contents of a single part of a multipart request and emits an `HttpPart` object for each part.\n * This consumes just enough of the stream to read the headers, and then forwards the rest of the stream as the body.\n */\nclass HttpPartTransform extends TransformStream<ReadableStream<Buffer>, HttpPart> {\n  constructor() {\n    super({\n      transform: async (partRaw, controller) => {\n        const reader = partRaw.getReader();\n\n        let buf = Buffer.alloc(0);\n        let idx;\n\n        while ((idx = buf.indexOf(BUF_CRLFCRLF)) === -1) {\n          const { done, value } = await reader.read();\n          if (done) {\n            throw new Error(\"Unexpected end of part.\");\n          }\n          buf = Buffer.concat([buf, value]);\n        }\n\n        const headerText = buf.subarray(0, idx).toString(\"utf-8\").trim();\n\n        const headers = Object.fromEntries(\n          headerText.split(\"\\r\\n\").map((line) => {\n            const [name, value] = line.split(\": \", 2);\n\n            return [name.toLowerCase(), value];\n          }),\n        ) as { [k: string]: string };\n\n        const body = new ReadableStream<Buffer>({\n          start(controller) {\n            controller.enqueue(buf.subarray(idx + BUF_CRLFCRLF.length));\n          },\n          async pull(controller) {\n            const { done, value } = await reader.read();\n\n            if (done) {\n              controller.close();\n            } else {\n              controller.enqueue(value);\n            }\n          },\n        });\n\n        controller.enqueue({ headers, body });\n      },\n    });\n  }\n}\n\n/**\n * Processes a request as a multipart request, returning a stream of `HttpPart` objects, each representing an individual\n * part in the multipart request.\n *\n * Only call this function if you have already validated the content type of the request and confirmed that it is a\n * multipart request.\n *\n * @throws Error if the content-type header is missing or does not contain a boundary field.\n *\n * @param request - the incoming request to parse as multipart\n * @returns a stream of HttpPart objects, each representing an individual part in the multipart request\n */\nexport function createMultipartReadable(request: http.IncomingMessage): ReadableStream<HttpPart> {\n  const boundary = request.headers[\"content-type\"]\n    ?.split(\";\")\n    .find((s) => s.includes(\"boundary=\"))\n    ?.split(\"=\", 2)[1];\n  if (!boundary) {\n    throw new Error(\"Invalid request: missing boundary in content-type.\");\n  }\n\n  const bodyStream = new ReadableStream<Uint8Array>({\n    start(controller) {\n      request.on(\"data\", (chunk: Buffer) => {\n        controller.enqueue(chunk);\n      });\n      request.on(\"end\", () => controller.close());\n    },\n  });\n\n  return bodyStream\n    .pipeThrough(MultipartBoundaryTransformStream(boundary))\n    .pipeThrough(new HttpPartTransform());\n}\n\n// Gross polyfill because Safari doesn't support this yet.\n//\n// https://bugs.webkit.org/show_bug.cgi?id=194379\n// https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream#browser_compatibility\n(ReadableStream.prototype as any)[Symbol.asyncIterator] ??= async function* () {\n  const reader = this.getReader();\n  try {\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) return value;\n      yield value;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n};\n\ndeclare global {\n  interface ReadableStream<R> {\n    [Symbol.asyncIterator](): AsyncIterableIterator<R>;\n  }\n}\n",
  },
  "router": {
    name: "router.ts",
    code: "// Copyright (c) Microsoft Corporation\n// Licensed under the MIT license.\n\nimport type * as http from \"node:http\";\n\n/** A policy that can be applied to a route or a set of routes. */\nexport interface Policy {\n  /** Optional policy name. */\n  name?: string;\n\n  /**\n   * Applies the policy to the request.\n   *\n   * Policies _MUST_ call `next()` to pass the request to the next policy _OR_ call `response.end()` to terminate,\n   * and _MUST NOT_ do both.\n   *\n   * If the policy passes a `request` object to `next()`, that request object will be used instead of the original\n   * request object for the remainder of the policy chain. If the policy does _not_ pass a request object to `next()`,\n   * the same object that was passed to this policy will be forwarded to the next policy automatically.\n   *\n   * @param request - The incoming HTTP request.\n   * @param response - The outgoing HTTP response.\n   * @param next - Calls the next policy in the chain.\n   */\n  (ctx: HttpContext, next: (request?: http.IncomingMessage) => void): void;\n}\n\n/**\n * Create a function from a chain of policies.\n *\n * This returns a single function that will apply the policy chain and eventually call the provided `next()` function.\n *\n * @param name - The name to give to the policy chain function.\n * @param policies - The policies to apply to the request.\n * @param out - The function to call after the policies have been applied.\n */\nexport function createPolicyChain<Out extends (ctx: HttpContext, ...rest: any[]) => void>(\n  name: string,\n  policies: Policy[],\n  out: Out,\n): Out {\n  let outParams: any[];\n  if (policies.length === 0) {\n    return out;\n  }\n\n  function applyPolicy(ctx: HttpContext, index: number) {\n    if (index >= policies.length) {\n      return out(ctx, ...outParams);\n    }\n\n    policies[index](ctx, function nextPolicy(nextRequest) {\n      applyPolicy(\n        {\n          ...ctx,\n          request: nextRequest ?? ctx.request,\n        },\n        index + 1,\n      );\n    });\n  }\n\n  return {\n    [name](ctx: HttpContext, ...params: any[]) {\n      outParams = params;\n      applyPolicy(ctx, 0);\n    },\n  }[name] as Out;\n}\n\n/**\n * The type of an error encountered during request validation.\n */\nexport type ValidationError = string;\n\n/**\n * An object specifying the policies for a given route configuration.\n */\nexport type RoutePolicies<RouteConfig extends { [k: string]: object }> = {\n  [Interface in keyof RouteConfig]?: {\n    before?: Policy[];\n    after?: Policy[];\n    methodPolicies?: {\n      [Method in keyof RouteConfig[Interface]]?: Policy[];\n    };\n  };\n};\n\n/**\n * Create a policy chain for a given route.\n *\n * This function calls `createPolicyChain` internally and orders the policies based on the route configuration.\n *\n * Interface-level `before` policies run first, then method-level policies, then Interface-level `after` policies.\n *\n * @param name - The name to give to the policy chain function.\n * @param routePolicies - The policies to apply to the routes (part of the route configuration).\n * @param interfaceName - The name of the interface that the route belongs to.\n * @param methodName - The name of the method that the route corresponds to.\n * @param out - The function to call after the policies have been applied.\n */\nexport function createPolicyChainForRoute<\n  RouteConfig extends { [k: string]: object },\n  InterfaceName extends keyof RouteConfig,\n  Out extends (ctx: HttpContext, ...rest: any[]) => void,\n>(\n  name: string,\n  routePolicies: RoutePolicies<RouteConfig>,\n  interfaceName: InterfaceName,\n  methodName: keyof RouteConfig[InterfaceName],\n  out: Out,\n): Out {\n  return createPolicyChain(\n    name,\n    [\n      ...(routePolicies[interfaceName]?.before ?? []),\n      ...(routePolicies[interfaceName]?.methodPolicies?.[methodName] ?? []),\n      ...(routePolicies[interfaceName]?.after ?? []),\n    ],\n    out,\n  );\n}\n\n/**\n * Options for configuring a router with additional functionality.\n */\nexport interface RouterOptions<\n  RouteConfig extends { [k: string]: object } = { [k: string]: object },\n> {\n  /**\n   * The base path of the router.\n   *\n   * This should include any leading slashes, but not a trailing slash, and should not include any component\n   * of the URL authority (e.g. the scheme, host, or port).\n   *\n   * Defaults to \"\".\n   */\n  basePath?: string;\n\n  /**\n   * A list of policies to apply to all routes _before_ routing.\n   *\n   * Policies are applied in the order they are listed.\n   *\n   * By default, the policy list is empty.\n   *\n   * Policies _MUST_ call `next()` to pass the request to the next policy _OR_ call `response.end()` to terminate\n   * the response and _MUST NOT_ do both.\n   */\n  policies?: Policy[];\n\n  /**\n   * A record of policies that apply to specific routes.\n   *\n   * The policies are provided as a nested record where the keys are the business-logic interface names, and the values\n   * are records of the method names in the given interface and the policies that apply to them.\n   *\n   * By default, no additional policies are applied to the routes.\n   *\n   * Policies _MUST_ call `next()` to pass the request to the next policy _OR_ call `response.end()` to terminate\n   * the response and _MUST NOT_ do both.\n   */\n  routePolicies?: RoutePolicies<RouteConfig>;\n\n  /**\n   * A handler for requests where the resource is not found.\n   *\n   * The router will call this function when no route matches the incoming request.\n   *\n   * If this handler is not provided, a 404 Not Found response with a text body will be returned.\n   *\n   * You _MUST_ call `response.end()` to terminate the response.\n   *\n   * This handler is unreachable when using the Express middleware, as it will forward non-matching requests to the\n   * next middleware layer in the stack.\n   *\n   * @param ctx - The HTTP context for the request.\n   */\n  onRequestNotFound?: (ctx: HttpContext) => void;\n\n  /**\n   * A handler for requests that fail to validate inputs.\n   *\n   * If this handler is not provided, a 400 Bad Request response with a JSON body containing some basic information\n   * about the error will be returned to the client.\n   *\n   * You _MUST_ call `response.end()` to terminate the response.\n   *\n   * @param ctx - The HTTP context for the request.\n   * @param route - The route that was matched.\n   * @param error - The validation error that was thrown.\n   */\n  onInvalidRequest?: (ctx: HttpContext, route: string, error: ValidationError) => void;\n\n  /**\n   * A handler for requests that throw an error during processing.\n   *\n   * If this handler is not provided, a 500 Internal Server Error response with a text body and no error details will be\n   * returned to the client.\n   *\n   * You _MUST_ call `response.end()` to terminate the response.\n   *\n   * If this handler itself throws an Error, the router will respond with a 500 Internal Server Error\n   *\n   * @param ctx - The HTTP context for the request.\n   * @param error - The error that was thrown.\n   */\n  onInternalError?(ctx: HttpContext, error: Error): void;\n}\n\n/** Context information for operations carried over the HTTP protocol. */\nexport interface HttpContext {\n  /** The incoming request to the server. */\n  request: http.IncomingMessage;\n  /** The outgoing response object. */\n  response: http.ServerResponse;\n\n  /**\n   * Error handling functions provided by the HTTP router. Service implementations may call these methods in case a\n   * resource is not found, a request is invalid, or an internal error occurs.\n   *\n   * These methods will respond to the client with the appropriate status code and message.\n   */\n  errorHandlers: {\n    /**\n     * Signals that the requested resource was not found.\n     */\n    onRequestNotFound: Exclude<RouterOptions[\"onRequestNotFound\"], undefined>;\n    /**\n     * Signals that the request was invalid.\n     */\n    onInvalidRequest: Exclude<RouterOptions[\"onInvalidRequest\"], undefined>;\n    /**\n     * Signals that an internal error occurred.\n     */\n    onInternalError: Exclude<RouterOptions[\"onInternalError\"], undefined>;\n  };\n}\n",
  },
} as const;

export const HELPERS = {
  "temporal": {
    "native": new Proxy(Object.create(null), {
      get: (_target: any, prop: string) => {
        if (typeof prop === "string")
          return <Helper helper={_helpers.temporal.native} name={prop} />;
    
        return undefined;
      },
    }),
    "polyfill": new Proxy(Object.create(null), {
      get: (_target: any, prop: string) => {
        if (typeof prop === "string")
          return <Helper helper={_helpers.temporal.polyfill} name={prop} />;
    
        return undefined;
      },
    }),
  },
  "datetime": new Proxy(Object.create(null), {
    get: (_target: any, prop: string) => {
      if (typeof prop === "string")
        return <Helper helper={_helpers.datetime} name={prop} />;
  
      return undefined;
    },
  }),
  "header": new Proxy(Object.create(null), {
    get: (_target: any, prop: string) => {
      if (typeof prop === "string")
        return <Helper helper={_helpers.header} name={prop} />;
  
      return undefined;
    },
  }),
  "http": new Proxy(Object.create(null), {
    get: (_target: any, prop: string) => {
      if (typeof prop === "string")
        return <Helper helper={_helpers.http} name={prop} />;
  
      return undefined;
    },
  }),
  "json": new Proxy(Object.create(null), {
    get: (_target: any, prop: string) => {
      if (typeof prop === "string")
        return <Helper helper={_helpers.json} name={prop} />;
  
      return undefined;
    },
  }),
  "multipart": new Proxy(Object.create(null), {
    get: (_target: any, prop: string) => {
      if (typeof prop === "string")
        return <Helper helper={_helpers.multipart} name={prop} />;
  
      return undefined;
    },
  }),
  "router": new Proxy(Object.create(null), {
    get: (_target: any, prop: string) => {
      if (typeof prop === "string")
        return <Helper helper={_helpers.router} name={prop} />;
  
      return undefined;
    },
  }),
} as const;

export function HelperTree() {
  return (
    <ay.SourceDirectory path="helpers">
      <ay.SourceDirectory path="temporal">
        <HelperModule helper={_helpers.temporal.native} />
        <HelperModule helper={_helpers.temporal.polyfill} />
      </ay.SourceDirectory>
      <HelperModule helper={_helpers.datetime} />
      <HelperModule helper={_helpers.header} />
      <HelperModule helper={_helpers.http} />
      <HelperModule helper={_helpers.json} />
      <HelperModule helper={_helpers.multipart} />
      <HelperModule helper={_helpers.router} />
    </ay.SourceDirectory>
  );
}
